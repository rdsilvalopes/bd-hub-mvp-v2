name: Nightly DB Backup

on:
  schedule:
    - cron: "0 3 * * *"        # 03:00 UTC diariamente
  workflow_dispatch: {}

permissions:
  contents: read               # checkout

jobs:
  backup:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Instala o cliente PostgreSQL 17 (pg_dump 17)
      - name: Install PostgreSQL 17 client
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo mkdir -p /etc/apt/keyrings
          curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc \
            | sudo tee /etc/apt/keyrings/postgresql.asc >/dev/null
          echo "deb [signed-by=/etc/apt/keyrings/postgresql.asc] http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" \
            | sudo tee /etc/apt/sources.list.d/pgdg.list >/dev/null
          sudo apt-get update
          sudo apt-get install -y postgresql-client-17
          /usr/lib/postgresql/17/bin/pg_dump --version

      - name: Prepare folder
        run: mkdir -p backups

      - name: Dump database (force IPv4 + SSL if needed)
        env:
          DB_URL: ${{ secrets.SUPABASE_DB_URL }}
        run: |
          set -euo pipefail

          # normaliza a URL
          CLEAN="$(printf '%s' "$DB_URL" | tr -d '[:space:]')"

          # extrai o host
          HOST="$(printf '%s' "$CLEAN" | sed -E 's#^postgres(ql)?://([^@]+@)?([^:/?]+).*#\3#')"

          # tenta resolver IPv4 e força via PGHOSTADDR (evita IPv6)
          IPV4="$(getent ahostsv4 "$HOST" | awk 'NR==1{print $1}')"
          if [ -n "${IPV4:-}" ]; then
            export PGHOSTADDR="$IPV4"
            echo "Resolved $HOST -> $PGHOSTADDR"
          else
            echo "WARNING: could not resolve IPv4 for $HOST (following default resolver)"
          fi

          # garante sslmode=require na URI
          case "$CLEAN" in
            *\?*) URI="${CLEAN}&sslmode=require" ;;
            *)    URI="${CLEAN}?sslmode=require" ;;
          esac

          TS="$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
          F="db_${TS}.dump.gz"
          PGDUMP="/usr/lib/postgresql/17/bin/pg_dump"

          # dump custom format + gzip
          "$PGDUMP" --dbname="$URI" --format=custom --no-owner --no-acl \
            | gzip -c > "backups/$F"

          echo "FILENAME=$F" >> "$GITHUB_ENV"
          echo "Dump created: backups/$F"

      # (opcional) publique o arquivo como artifact do workflow
      - name: Upload artifact (optional)
        uses: actions/upload-artifact@v4
        with:
          name: nightly-db-backup
          path: backups/${{ env.FILENAME }}
          retention-days: 7

      # (opcional) enviar o arquivo para o repositório de backups
      - name: Push to backup repo
        if: env.FILENAME != ''
        env:
          BACKUP_PAT:  ${{ secrets.BACKUP_PAT }}
          BACKUP_REPO: ${{ secrets.BACKUP_REPO }}   # ex.: rdsilvalopes/bidly-backups
        run: |
          set -euo pipefail

          git config --global user.name  "backup-bot"
          git config --global user.email "actions@users.noreply.github.com"

          rm -rf backup-repo
          git clone --depth 1 "https://x-access-token:${BACKUP_PAT}@github.com/${BACKUP_REPO}.git" backup-repo

          # organiza por data (YYYY/MM/DD)
          DEST_DIR="backup-$(date -u +%Y/%m/%d)"
          mkdir -p "backup-repo/${DEST_DIR}"
          cp "backups/${FILENAME}" "backup-repo/${DEST_DIR}/"

          cd backup-repo
          git add -A

          if git diff --cached --quiet; then
            echo "Nothing to commit (same file already exists)."
          else
            git commit -m "DB backup: ${FILENAME}"
            git push origin HEAD
          fi

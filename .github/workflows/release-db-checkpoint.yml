name: Release DB Checkpoint

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag para salvar (se rodar manualmente)"
        required: false
        default: ""

permissions:
  contents: read

env:
  BACKUP_REPO: ${{ secrets.BACKUP_REPO }}       # ex.: rdsilvalopes/bidly-backups
  DB_URL:      ${{ secrets.SUPABASE_DB_URL }}   # URI do pooler com senha (sem colchetes)
  GH_TOKEN:    ${{ secrets.BACKUP_PAT }}        # PAT com contents:read&write no repo de backups

  TAG_NAME: ${{ github.event.release.tag_name || github.event.inputs.tag || github.ref_name }}
  GIT_SHA:  ${{ github.sha }}
  GIT_REF:  ${{ github.ref_name }}
  RUN_ID:   ${{ github.run_id }}

jobs:
  checkpoint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Prepare folder
        id: prep
        run: |
          set -euo pipefail
          TS="$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
          echo "ts=$TS" >> "$GITHUB_OUTPUT"
          mkdir -p backups

      - name: Dump DB with pg_dump 17 (Docker: postgres:17-alpine)
        id: dump
        shell: bash
        env:
          TS: ${{ steps.prep.outputs.ts }}
        run: |
          set -euo pipefail

          # 1) Normaliza URL
          CLEAN="$(printf '%s' "$DB_URL" | tr -d '[:space:]')"

          # 2) Extrai host e resolve IPv4 (evita IPv6)
          HOST="$(printf '%s' "$CLEAN" | sed -E 's#^postgres(ql)?://([^@]+@)?([^/:?]+).*$#\3#')"
          IPV4="$(getent ahostsv4 "$HOST" | awk 'NR==1{print $1}')"
          if [ -n "${IPV4:-}" ]; then
            EXTRA="-e PGHOSTADDR=$IPV4"
            echo "Resolved $HOST -> $IPV4"
          else
            EXTRA=""
            echo "WARNING: IPv4 not resolved; following default resolver"
          fi

          # 3) SSL obrigatÃ³rio
          case "$CLEAN" in
            *sslmode=*) URI="$CLEAN" ;;
            *)           URI="${CLEAN}?sslmode=require" ;;
          esac

          # 4) Faz o dump usando pg_dump v17 dentro do container oficial
          F="db_${TS}.dump.gz"
          docker run --rm -i $EXTRA -e URI="$URI" postgres:17-alpine \
            sh -lc 'pg_dump --dbname="$URI" --format=custom --no-owner --no-acl' \
            | gzip -c > "backups/$F"

          echo "file=$F" >> "$GITHUB_OUTPUT"

      - name: Build manifest.json
        id: manifest
        run: |
          set -euo pipefail
          TS="${{ steps.prep.outputs.ts }}"
          FILE="${{ steps.dump.outputs.file }}"
          PGDUMP_VER="17.x (docker postgres:17-alpine)"
          MIGRATION_HEAD="$(ls -1 db/migrations 2>/dev/null | tail -n 1 || true)"

          cat > backups/manifest.json <<JSON
          {
            "timestamp_utc": "${TS}",
            "app": {
              "git_sha": "${GIT_SHA}",
              "git_ref": "${GIT_REF}"
            },
            "db": {
              "dump_file": "${FILE}",
              "pg_dump_version": "${PGDUMP_VER}",
              "migration_head": "${MIGRATION_HEAD}"
            },
            "run": {
              "github_run_id": "${RUN_ID}",
              "workflow": "Release DB Checkpoint (docker)"
            }
          }
          JSON

      - name: Push to backup repo (releases/<tag>/)
        env:
          DEST: https://github.com/${{ env.BACKUP_REPO }}.git
        run: |
          set -euo pipefail
          TAG="${TAG_NAME:-manual}"
          echo "Checkpoint tag: $TAG"

          git clone --depth=1 "$DEST" out
          cd out
          mkdir -p "releases/${TAG}"
          cp -v ../backups/* "releases/${TAG}/"

          git config user.name  "Backup Bot"
          git config user.email "backup-bot@users.noreply.github.com"
          git add "releases/${TAG}"
          git commit -m "checkpoint: ${TAG} (sha=${GIT_SHA:0:8})" || echo "No changes to commit"
          git push origin HEAD

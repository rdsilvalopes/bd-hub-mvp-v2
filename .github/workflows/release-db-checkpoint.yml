name: Release DB Checkpoint

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag (ex.: v1.2.3). Se vazio, usa a tag do release ou o ref atual."
        required: false
        default: ""

permissions:
  contents: read

env:
  # Segredos necessários
  BACKUP_REPO: ${{ secrets.BACKUP_REPO }}       # ex.: rdsilvalopes/bidly-backups
  DB_URL:      ${{ secrets.SUPABASE_DB_URL }}   # URI do pooler com senha (sem colchetes)
  GH_TOKEN:    ${{ secrets.BACKUP_PAT }}        # PAT com contents:write no repo de backups

jobs:
  checkpoint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Resolver TAG / timestamp
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          # Resolve TAG: 1) release -> tag_name; 2) input manual; 3) ref atual
          TAG=""
          if [ "${{ github.event_name }}" = "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
          fi
          if [ -z "$TAG" ]; then
            TAG="${{ github.event.inputs.tag }}"
          fi
          if [ -z "$TAG" ]; then
            TAG="${{ github.ref_name }}"
          fi

          TS="$(date -u +'%Y-%m-%dT%H-%M-%SZ')"

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "ts=$TS"   >> "$GITHUB_OUTPUT"
          echo "Tag resolvida: $TAG"
          echo "Timestamp: $TS"

      - name: Preparar pasta local
        run: |
          set -euo pipefail
          rm -rf backups
          mkdir -p backups

      - name: Dump DB (pg_dump 17 via Docker)
        id: dump
        shell: bash
        env:
          TS: ${{ steps.meta.outputs.ts }}
        run: |
          set -euo pipefail

          CLEAN="$(printf '%s' "$DB_URL" | tr -d '[:space:]')"
          HOST="$(printf '%s' "$CLEAN" | sed -E 's#^postgres(ql)?://([^@]+@)?([^/:?]+).*$#\3#')"

          # Força IPv4 (PGHOSTADDR) se resolvido
          IPV4="$(getent ahostsv4 "$HOST" | awk 'NR==1{print $1}')"
          EXTRA=""
          if [ -n "${IPV4:-}" ]; then
            echo "Resolved $HOST -> $IPV4"
            EXTRA="-e PGHOSTADDR=$IPV4"
          else
            echo "WARNING: IPv4 not resolved (seguindo resolução padrão)"
          fi

          # SSL obrigatório
          case "$CLEAN" in
            *sslmode=*) URI="$CLEAN" ;;
            *)           URI="${CLEAN}?sslmode=require" ;;
          esac

          F="db_${TS}.dump.gz"
          # Executa pg_dump 17 dentro do container oficial (sem depender de apt)
          docker run --rm -i $EXTRA -e URI="$URI" postgres:17-alpine \
            sh -lc 'pg_dump --dbname="$URI" --format=custom --no-owner --no-acl' \
            | gzip -c > "backups/$F"

          echo "file=$F" >> "$GITHUB_OUTPUT"
          echo "Dump gerado: backups/$F"

      - name: Escrever manifest.json
        run: |
          set -euo pipefail
          TS="${{ steps.meta.outputs.ts }}"
          FILE="${{ steps.dump.outputs.file }}"
          PGDUMP_VER="17.x (docker postgres:17-alpine)"
          MIGRATION_HEAD="$(ls -1 db/migrations 2>/dev/null | tail -n 1 || true)"

          cat > backups/manifest.json <<JSON
          {
            "timestamp_utc": "${TS}",
            "app": {
              "git_sha": "${{ github.sha }}",
              "git_ref": "${{ github.ref_name }}"
            },
            "db": {
              "dump_file": "${FILE}",
              "pg_dump_version": "${PGDUMP_VER}",
              "migration_head": "${MIGRATION_HEAD}"
            },
            "run": {
              "github_run_id": "${{ github.run_id }}",
              "workflow": "Release DB Checkpoint (docker)"
            }
          }
          JSON
          cat backups/manifest.json

      - name: Push para repo de backups (releases/<TAG>/)
        shell: bash
        env:
          TAG: ${{ steps.meta.outputs.tag }}
        run: |
          set -euo pipefail

          if [ -z "${TAG:-}" ]; then
            echo "TAG vazia — abortando."
            exit 1
          fi

          # Evita vazar PAT nos logs
          git config --global url."https://${GH_TOKEN}@github.com/".insteadOf "https://github.com/"

          git clone --depth=1 "https://github.com/${BACKUP_REPO}.git" out
          cd out

          mkdir -p "releases/${TAG}"
          cp -v ../backups/* "releases/${TAG}/"

          git config user.name  "Backup Bot"
          git config user.email "backup-bot@users.noreply.github.com"
          git add "releases/${TAG}"
          git commit -m "checkpoint: ${TAG} (sha=${GITHUB_SHA:0:8})" || echo "Nada a commitar"
          git push origin HEAD
